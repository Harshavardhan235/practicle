Prompt 1:Code Generation & Debugging

I want to generate a Factory Monitoring System in Python. Requirements:

OOP Design: Classes → Sensor, Machine, FactoryMonitor.
Machine health formula:
100 - (TEMP_WEIGHT * temp + PRESSURE_WEIGHT * pressure + VIBRATION_WEIGHT * vibration)
where constants TEMP_WEIGHT=0.5, PRESSURE_WEIGHT=0.1, VIBRATION_WEIGHT=20.

Alerts:
Health < 50 → "Critical Machine Failure Risk"
Missing sensor → "Sensor Offline Warning"
Input: Load machine + sensor data from CSV (not hardcoded).

Debugging Best Practices:
Use try/except with clear error messages
Validate CSV (raise ValueError if malformed/empty)
Use logging module (INFO, WARNING, ERROR levels)
Write efficient loops and PEP8 clean style

Project Structure:
sensor.py
machine.py
factory_monitor.py
main.py

Documentation: Add docstrings to all files/classes/functions.


Prompt 2:Code Review & Refactoring
Replace hardcoded arrays with OOP (Sensor, Machine, FactoryMonitor).

Encapsulation: Use private attributes (_id, _sensors) and properties for controlled access.

Constants: Replace magic numbers with named constants (TEMP_WEIGHT, PRESSURE_WEIGHT, VIBRATION_WEIGHT).

Validation:
Validate CSV input format.
Raise ValueError on malformed/empty data.

Design Principles:
Apply SOLID principles
Apply at least one design pattern (Factory Pattern for sensor creation).

Code Quality:
Improve readability & maintainability.
Remove redundancy with helper methods.
Apply type hints (-> int, -> float, etc.).
Ensure PEP8 compliance and scalability for future sensors/machines.



Prompt 3 : Unit Testing
Write comprehensive pytest tests for the Factory Monitoring System. Requirements:

Critical alert: Machine with high temp/pressure/vibration → health < 50 → "Critical Machine Failure Risk".

Sensor warning: Machine missing a sensor → "Sensor Offline Warning".

Average health: Verify FactoryMonitor computes correct average across multiple machines.

Boundary case: health = 50 → no alert.

CSV validation:
Empty CSV → raise ValueError.
Malformed CSV → raise ValueError.

Mocking/Stubs:
Mock sensors to simulate live sensor updates.
Test concurrency mode with simulated sensor data.

Place tests inside tests/test_factory.py.

Follow PEP8 & Arrange-Act-Assert structure for readability.




Prompt 4: Documentation

Generate a professional README.md for the Factory Monitoring System. Must include:

Introduction: Explain OOP-based factory health monitoring (sensors → machine health → factory overview).

Architecture Diagram (ASCII or markdown image).

Classes: Describe Sensor, Machine, FactoryMonitor.

Usage:
python main.py
pytest -v

Example CSV Input and Expected Output.

Concurrency: Explain sequential vs threaded simulation.

Documentation Tools: Mention auto-generated API docs using pdoc or sphinx.

Keywords: Encapsulation, modular design, scalability, concurrency.

Future Work: Extend to IoT sensors, dashboards, multiprocessing.


Prompt 5: Concurrency

Enhance the Factory Monitoring System with concurrency & performance testing. Requirements:

Sequential Simulation: Iterate through machines, update sensor readings one by one.

Threaded Simulation: Use threading.Thread to update machines concurrently.

Thread Safety: Use threading.Lock around shared state (health calculation).

Multiprocessing Extension: Add option with multiprocessing.Process for CPU-bound tasks.

Performance Comparison:
Compare sequential, threaded, and multiprocessing execution times.
Print results in main.py.

FactoryMonitor: Concurrency logic inside factory_monitor.py.

Main Program: Demonstrate both modes with sample runs.

Ensure clean shutdown of threads/processes (no orphaned workers).
